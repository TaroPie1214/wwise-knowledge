# 关于降低内存占用的技巧

|  |
| --- |
| Wwise SDK 2025.1.4 - Windows |

关于降低内存占用的技巧

依据规定限值削减内存用量并不是一件容易的事。以下是帮助降低内存占用的几个技巧：

- [Object 内存](goingfurther_optimizingmempools_reducing_memory.html#goingfurther_optimizingmempools_reducing_memory_object)
- [Processing 内存](goingfurther_optimizingmempools_reducing_memory.html#goingfurther_optimizingmempools_reducing_memory_processing)
- [媒体内存（ SoundBank ）](goingfurther_optimizingmempools_reducing_memory.html#goingfurther_optimizingmempools_reducing_memory_media)
- [调节 Temp Alloc 内存](goingfurther_optimizingmempools_reducing_memory.html#goingfurther_optimizingmempools_tempallocs)
- [调节 Bookmark Allocator 内存](goingfurther_optimizingmempools_reducing_memory.html#goingfurther_optimizingmempools_bookmarkalloc)

# Object 内存

Object 内存用量直接受内存中加载的声音和 Event 数量以及游戏对象数量影响。它包含工程中用于实现声音设计的行为所必需的对象的所有属性。它还包含所有游戏对象及其相关信息（游戏同步器值、位置、朝向等）。加载的 SoundBank 越多，所需分配的内存就越多。所需的大小完全取决于在一个场景、关卡、地图、游戏区域等中可能播放的声音数量。您可以采用以下做法来减少这些内存分配：

- **将装有大量声音结构和事件的大型 SoundBank 分割成小型 SoundBank**。作为参考，您可以转到 Advanced Profiler（高级性能分析器）的 SoundBanks（音频包）选项卡，并在 Object Memory（对象内存）列中查看每个 SoundBank 占用了多少内存。然后您可以根据需要动态地加载和卸载 SoundBank。要做策略性地来考虑如何划分 SoundBank。例如，在划分对白 SoundBank 时，要避免创建的 SoundBank 中只包含属于单个角色的对白。相反，应根据环境将对白分组。
- **使用 [AK::SoundEngine::ExecuteActionOnEvent](namespace_a_k_1_1_sound_engine_ac55e3d6ac464b0579a8487c88a755d8c.html#ac55e3d6ac464b0579a8487c88a755d8c) API 来减少事件的数量**。Play／Stop（播放/停止）这对事件可以替换成一个播放事件外加调用一次 [ExecuteActionOnEvent](namespace_a_k_1_1_sound_engine_ac55e3d6ac464b0579a8487c88a755d8c.html#ac55e3d6ac464b0579a8487c88a755d8c) API 来执行 Stop 动作；Pause／Resume（暂停/续播）也可以用和 Play 事件相同的手法来处理。
- **严格地管理 Game Object**。它们的任务一旦完成，则应立即注销它们。避免保留大量未使用的游戏对象而不注销；这样做毫无益处，只会消耗内存。例如，假想有一个 NPC（非玩家角色）死了，则应注销它的 Game Object；不要将它复用于其他角色。需要时再注册一个全新的角色。一般来说，如果您有数千个游戏对象在活动，则这样的数量实在是太多了。
- **Do not use Property Containers only to organize sounds**. Folders and Work Units do not take memory, Property Containers do. 除非您想让多个对象共享相似的属性值，且这些值不是默认的属性值，否则仅仅为了编组对象而使用 Actor-Mixer 将浪费内存。Of course, this also depends if the Property Container is referenced by events (such as SetVolume or SetPitch).
- **尽量降低大型层级结构的大小和复杂性**。大型层级结构的常见例子有表现“撞击”或“脚步”的层级结构。由于有大量的变量，因此层级结构可能会很大，并占用大量的内存来容纳结构。以下是减少此类层级结构的几种方法：
  - 如果采用 Switch 切换造成的唯一变化是一个简单属性（样本素材相同，只是音量/音高/随机化器等不同），则应换用 RTPC。
  - 将 Switch Container 层级结构分到多个 SoundBank中去。在 SoundBank Manager 中，当您包含某个 Switch Container 时，还会包含它的所有子分支。然而，您可以在 SoundBank Editor 视图中的 Game Sync 选项卡或 Edit 选项卡中手动排除某些分支。例如，在“脚步”层级结构中，第一个 Switch 变量可以是 Surface Type（地表类型）。然后您可以把多个 Switch 分散放在不同的 SoundBank 中，并根据环境加载这些 SoundBank。您可以创建一个主要的“脚步” SoundBank，让它包含在整个游戏中将遇到的地表类型（城市环境中的混凝土和金属台阶），再创建其它环境相关的 SoundBank 用来装特定的地表类型，例如仅在游戏某一个场景/部分中使用的泥土地。
- **Use "external sources" to reduce the overhead of sounds that do not need as much control as offered by the Wwise Containers hierarchy**. 这通常适用于语音素材。

# Processing 内存

Processing 类别中的内存用于播放声音。它包含用于解压缩、应用效果器和对音频源做混音的缓冲区。它直接受到同时播放的声音数量的影响。它还受到同时使用的效果器数量和类型的影响。为了节省内存，您需要考虑想同时听到多少声音。某些游戏中很少有超过10种声音的场景，而别的游戏的场景中则可能有数百个声音。您需要考虑最坏的情况。

作为参照指南，我们对一些游戏执行了性能分析（在Xbox One 上），并获得了以下数据：

- 1 MB 可让您播放大约 42 个声部
- 2 MB可让您播放大约 96 个声部 虽然这个性能指标几乎是按线性来伸缩的，但真正还取决于使用的编解码器、效果器数量和其他一些因素。例如，使用 Vorbis 编解码器时，根据质量设置，各个声部将多占用大约 50% 的内存。假想同时播放 170 个声音：这样做可能很难让人听清楚各个声音，因此是无用的。然而，需要实验一下才能为您的游戏找到理想数量的声部。使用性能分析器的 Memory 选项卡，对游戏中的多个场景进行性能分析，并记下资源中使用了多少内存。

为了降低处理所需的内存用量，您需要减少同时播放的声部数。通过以下方式可以做到这一点：

- **Playback Limits**（Advanced Settings），高级设置中的播放限制。例如，您真的需要听到 50 种子弹飞啸声吗？如果不是，则可将这些声音的个数限制在例如 15 个以内。

  |  |  |
  | --- | --- |
  |  | **备注:** 您还可以对总线也设置限制。 |
- **Priority**（Advanced Settings），高级设置中的优先级。例如，子弹可能没有对白重要。这意味着如果声音太多，首先被踢出的应该是子弹。将优先级与播放限制结合使用。
- **基于距离的优先级偏置** （Advanced Settings）。距离远的对象通常没有距离近的对象重要。再以子弹为例，如果有 15 个子弹声音距离小于 10 米，则我们不需要听到 10 米以外的子弹声。
- **Below Threshold Behavior**（高级设置）。性能最优的选择（针对 CPU 和内存而言）是“Kill Voice”，这对非循环的声音非常有用。性能上的次优选择是“Send To Virtual”“Play from beginning”，再次是“Send To Virtual”“Resume”，最后是“Send To Virtual”“Play from elapsed time”。“Continue to play”和“Play from elapsed time”是性能上最昂贵的选择，Wwise 的默认值是“Continue To Play”。
- **Volume Threshold**（Project Settings），工程设置中的音量阈值。这有助于终结声音太小而听不清的声音。此选项结合 Below Threshold Behavior 和 Attenuation 设置（离得越远通常意味着越听不清）一起使用。

  |  |  |
  | --- | --- |
  |  | **备注:** 您可以在运行时以编程的方式更改音量阈值。您可以在游戏中 CPU 运算更繁重的位置使用此设置，以将更多的声部发送到“低于音量阈值”的状态。 |
- **更改已经使用的编解码设置**（Conversion Settings）。Vorbis 需要额外的内存来解压缩音频。不同的参数可以提高或降低内存需求量。不过要认真权衡：使用其他编解码器或较小的压缩比可以减轻 Processing 内存负荷；但若以 SoundBank 的形式加载，则需在内存中存储较大的文件。在有些情况下，最好在 Processing 内存用量中多分配 500 KB。这样可以节省数 MB 的 Media 内存，从而降低总体音频预算。
- **更小或更低的品质**。某些效果器运算需要大量的内存。一个常见的内存消耗大户是混响效果器，无论采用什么类型的混响，都会消耗大量的内存。实际上，您的游戏不应有很多并发运行的混响。我们一般建议少于 4 个。另外降低混响的品质或长度也会有用。

# 媒体内存（ SoundBank ）

SoundBank 占用的内存量几乎都取决于 SoundBank 中的声音数据。控制媒体所占用的内存量可通过以下方式来做到：

- 将装有大量声音结构和事件的大型 SoundBank 分割成小一些的 SoundBank。根据需要动态加载和卸载。
- 让更多声音采用从磁盘中流播放（通过声音属性来指定）。对延迟敏感的声音可使用可采用预读媒体来预先加载，或者使用 PinEventInStreamCache API 来按需流到缓存中去。
- 使用 [PrepareEvent()](namespace_a_k_1_1_sound_engine_a2e6ebb779470b43d78984c27f6a0c238.html#a2e6ebb779470b43d78984c27f6a0c238) API。
- 提高对音频的压缩（通过 Conversion Settings、编解码器等）。
- 使用更低的采样率。另请查看 Conversion Settings 中的 Automatic Sample Rate（自动采样率检测）功能。
- 将风声类型的声音替换成 SoundSeed Wind/Woosh 插件产生的等效声音。风声往往有较长的循环，可能会占用大量的媒体空间。锋刃的嗖嗖声、螺旋桨声、风通过打开的车窗刮起的呼呼声、通风噪声等都可使用此插件建模。另外也可以考虑非风声应用：可为任何嘈杂的声音建模。**示例：** 海浪的声音和远处高速公路上传来的声音。

# 调节 Temp Alloc 内存

Wwise 会使用内部内存池管理部分存续时间不超过一个 Audio Render 时钟周期的临时分配。这些临时分配在 Memory 选项卡的 Advanced Profiler 中显示为 Temp Alloc。它们会存在一段时间、开销很小，由声音引擎在内部进行处理，且无法传给开发者提供的内存分配挂钩。在这当中，Advanced Profiler 和内存分配挂钩只能监控到临时分配所基于的较大内存块。因此，为了更好地优化游戏中的内存用量，最好手动调节 Temp Alloc 内存块的管理。

在 `AK::MemoryMgr::Init` 过程中，各个 Temp Alloc 类别的内存块的行为由 `AkMemSettings::tempAllocSettings` 控制。其中包括配置内存块的大小、限定系统至少要分配多少个内存块、规定一个时钟周期积存多少未使用的内存块系统才会释放内存。对此，您可以通过 `AK::TempAlloc::GetStats()` 来查看在游戏运行时 Temp Alloc 系统使用了多少内存以更好地调节系统的配置。

您可以参照以下建议并根据游戏的具体要求或性能分析期间观察到的其他行为实施调节：

- 若不在意内存块分配和释放的开销或释放内存块时产生的内存碎片，最好将 `AK::TempAlloc::InitSettings::uMinimumBlockSize` 调到默认值以下。这样可以更好地满足游戏在任意给定时间的内存使用需要。
- 若内存块的分配和释放产生过多内存碎片，则可估算 `AK::TempAlloc::Stats::uPeakMemUsed` 以了解 Temp Alloc 系统的内存用量峰值，确保将 `AK::TempAlloc::InitSettings::uMinimumBlockCount` 设为足够大的值，保证在初始化声音引擎时分配所有可能使用的内存块，之后不再释放。
- 若要避免在未估算内存用量峰值的情况下释放内存块，则可将 `AK::TempAlloc::InitSettings::uMaximumUnusedBlocks` 设为较大的值，以确保系统可分配新的内存块，即便在内存负荷较低的时候也不会释放。
- 若使用 Job Manager 管理音频渲染（如 [利用 Job Manager 并行执行音频渲染作业](goingfurther_eventmgrthread.html#eventmgrthread_jobmgr) 中所述），则内存块的数量将会增加。这是因为内存块都是线程本地的，一般每个活跃的工作线程都会分配一个内存块。为此，最好调低 `AK::TempAlloc::InitSettings::uMinimumBlockSize` 的值，以确保在使用更多工作线程时不会导致游戏中所用的内存大幅增加。

`AK::TempAlloc::InitSettings` 中有一些调试选项。在声音引擎的 Debug 和 Profile 配置中，默认会启用 `AK::TempAlloc::InitSettings::bDebugDetailedStats` 和 `AK::TempAlloc::InitSettings::bDebugEnableSentinels` ，以便优化对用量统计数据的追踪并轻松检测缓冲区溢出情况。在需要最大限度地提升性能或获取尽可能精确的性能分析数据时，请禁用这些选项。在声音引擎的 Release 配置中，已完全取消对这些选项的支持。

# 调节 Bookmark Allocator 内存

Wwise 设有 Bookmark Allocator 系统（与 Temp Alloc 类似），用于处理只存在于单个函数或代码块中的短时内存分配。藉此，Wwise 可以像在堆栈上一样执行临时内存分配。不过，Bookmark Allocator 并不依赖于为线程的堆栈分配足够大的内存来确保处理所有可能的情况，而是使用正常的内存分配来提供必要的资源。

您可以使用 `AkMemSettings::bookmarkAllocSettings` 来控制 Bookmark Allocator 类别的内存块的行为以便分配和释放底层内存块。另外，还可使用调试设置来检测缓冲区溢出情况，并在使用前后清理分配的内存来设为确定的无效值。同时，通过 [AK::BookmarkAlloc::GetStats](namespace_a_k_1_1_bookmark_alloc_a78703377dee103f212b970697b44b38f.html#a78703377dee103f212b970697b44b38f "Get simple statistics for the Bookmark allocator") 获取有关 Bookmark Allocator 使用情况的信息。

您可以参照以下建议并根据游戏的具体要求或性能分析期间观察到的其他行为实施调节：

- 若将 `AK::BookmarkAlloc::Stats::uRecentBlocksFetched` 设为较大的值，则在多线程场景下可能会产生过多线程争用情况。为此，最好调高 `AK::BookmarkAlloc::InitSettings::uMinimumBlockSize` 的值。这样 Bookmark Allocator 所用的内存块会更大一些，也就不需要经常临时请求获取新的内存块了。您可以使用 `AK::BookmarkAlloc::Stats::uRecentPeakMemUsed` 来确定合理的最小内存块大小。
- 相反，若发现并未使用提供的全部内存，则可估算 `AK::BookmarkAlloc::Stats::uPeakMemUsed` 来调低 `AK::BookmarkAlloc::InitSettings::uMinimumBlockSize` 的值。
- 若使用 Job Manager 管理音频渲染（如 [利用 Job Manager 并行执行音频渲染作业](goingfurther_eventmgrthread.html#eventmgrthread_jobmgr) 中所述），则所用内存块的数量将会增加。这是因为内存块都是线程本地的，一般每个活跃的工作线程至少会分配一个内存块。这样同样可能会导致频繁地分配和释放内存块。因为 1) 可能会出现大量不确定的内存块获取情形；2) 在执行声音引擎的调度时没有获取有些内存块而导致其被视为未被使用。为此，最好调高 `AK::BookmarkAlloc::InitSettings::uMaximumUnusedBlocks` 的值。这样内存的使用情况会更加一致。或者，也可调高 `AK::BookmarkAlloc::InitSettings::uMinimumBlockSize` 的值。这样作业获取的第一个内存块就够用了。