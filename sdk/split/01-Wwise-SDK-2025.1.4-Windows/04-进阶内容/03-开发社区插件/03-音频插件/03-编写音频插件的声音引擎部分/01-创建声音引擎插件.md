# 创建声音引擎插件

|  |
| --- |
| Wwise SDK 2025.1.4 - Windows |

创建声音引擎插件

Wwise 声音引擎插件的创建可以很有创意，但也可能会很复杂。我们强烈建议您仔细阅读以下章节，并结合查看 [示例插件](samplecode.html#samplecode_plugins) 部分提供的示例。您可以参考示例中提供的标准样式和结构来构建插件。

- [声音引擎插件概述](soundengine_plugins.html#se_plugins_overview)
- [插件静态注册](soundengine_plugins.html#register_effects)
- [创建动态库](soundengine_plugins.html#soundengine_plugins_binaries)
- [在音频插件中分配/取消分配内存](soundengine_plugins.html#fx_memory_alloc)
- [参数节点接口的实现](soundengine_plugins.html#shared_parameter_interface)
- [音频插件接口的实现](soundengine_plugins.html#software_effect_interface)
- [访问使用 AkAudioBuffer 结构的数据](soundengine_plugins.html#fx_audiobuffer_struct)
- [音频插件接口的实现](soundengine_plugins.html#software_effect_interface)
- [在插件中使用全局声音引擎回调](soundengine_plugins.html#fx_global_hooks)

# 声音引擎插件概述

插件可以让您将自定义 DSP 程序插入由声音引擎执行的整体信号处理链中。插件参数既可在设计工具中控制，也可在游戏中通过 RTPC 控制（请参阅 [了解 Real-Time Parameter Control (RTPC)](concept_rtpc.html) ）。

每个插件包括 2 个组件：

- 运行时组件，它集成在声音引擎中，可针对跨平台开发，或针对特定平台优化。游戏需要注册此插件（请参阅 [插件静态注册](soundengine_plugins.html#register_effects) ）并与其实现做链接。
- 设计工具组件，用于 SoundBank 生成和用户界面，集成在设计工具中。此组件位于由 Wwise 加载的 DLL 中（请参阅 [设计工具插件库格式](plugin_dll.html) ）。UI 中确定的所有插件参数存储在 SoundBank 中，因此游戏中不使用此组件。如果参数将通过 RTPC 在游戏中进行控制，则必要的信息也会存储在 SoundBank 中。

|  |  |
| --- | --- |
|  | **技巧:**为运行时组件创建通用静态库。通过这种方法，游戏和插件用户界面（Wwise 加载的 DLL）都可以链接它。 |

需要实现参数节点接口，以对来自声音引擎 RTPC 管理器或 Wwise 设计工具的更改做出反应，并在执行期间获取当前插件参数。（请参阅 [参数节点接口的实现](soundengine_plugins.html#shared_parameter_interface) 。）

可集成到声音引擎中的插件主要有 3 类：

- 源插件。源插件使用物理建模、调制合成、采样合成等合成方法产生音频内容。请参阅 [创建声音引擎源插件](soundengine_plugins_source.html) 了解更多信息。
- 效果器插件。效果器插件对现有声音应用 DSP 算法，将其当作输入音频数据进行处理。请参阅 [创建声音引擎效果器插件](soundengine_plugins_effects.html) 了解更多信息。
- 音频设备插件。音频设备插件在管线末端接收音频数据，并可把数据传递给其它声音系统。请参阅 [创建音频设备 (Sink) 插件](soundengine_plugins_audiodevices.html) 了解更多信息。

插件及其相关参数接口由声音引擎通过插件机制创建。该插件机制要求暴露静态创建函数，这些函数在必要时返回新参数节点和新插件实例。以下代码演示如何可以做到这一点。创建函数必须打包到插件库用户可见的 [AK::PluginRegistration](class_a_k_1_1_plugin_registration.html) 静态实例中。每个插件类别/类型需要一个 `AK::PluginRegistration` 类。

// 静态参数节点创建函数回调将注册到插件管理器中。

[AK::IAkPluginParam](class_a_k_1_1_i_ak_plugin_param.html) \* CreateMyPluginParams( [AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator )

{

return [AK\_PLUGIN\_NEW](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479)( in\_pAllocator, CAkMyPluginParams() );

}

// 静态插件创建函数回调将注册到插件管理器中。

[AK::IAkPlugin](class_a_k_1_1_i_ak_plugin.html) \* CreateMyPlugin( [AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator )

{

return [AK\_PLUGIN\_NEW](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479)( in\_pAllocator, CAkMyPlugin() );

}

//静态初始化器对象将自动把插件注册到声音引擎中。

[AK\_IMPLEMENT\_PLUGIN\_FACTORY](_i_ak_plugin_8h_a13b2972f82acec4f7cedcb073d51619c.html#a13b2972f82acec4f7cedcb073d51619c)(MyPlugin, [AkPluginTypeEffect](_ak_enums_8h_af1a95e76b0e2a003e7edb2ad6f4043f4.html#af1a95e76b0e2a003e7edb2ad6f4043f4a2971cc4c818bf62c55175445d2be117d), AKCOMPANYID\_MYCOMPANY, EFFECTID\_MYPLUGIN);

|  |  |
| --- | --- |
|  | **备注:** 根据您要制作的插件类型，设置 `AK::PluginRegistration` 函数的 AkPluginType 参数。例如，源插件的 AkPluginTypeSource、效果器插件的 AkPluginTypeEffect 。 |

|  |  |
| --- | --- |
|  | **备注:** Registration 对象的命名非常重要。AK\_STATIC\_LINK\_PLUGIN(*pluginname*) 宏将使用它，在 \_pluginname\_后加上“Registration”。请参见下文的 [插件静态注册](soundengine_plugins.html#register_effects) 。 |

如果您是插件提供者，希望确保您的插件不会与来自其它供应商的插件有相同的 ID，则请联系 [support@audiokinetic.com](#) 以获得预留的公司 ID。

# 插件静态注册

各种音频插件全部由 Plug-in Manager 处理，后者可根据 CompanyID 和 PluginID 识别不同的插件类别。插件必须先在 Plug-in Manager 中注册，然后才可在游戏中使用。注册过程将 PluginID 绑定到以参数形式提供的创建函数回调上。

以下例程演示游戏注册插件的方式。如果游戏要使用 Audiokinetic 提供的插件，则也必须先注册插件。

为了方便使用，所有插件还有一个出厂头文件，其中只包含 AK\_STATIC\_LINK\_PLUGIN 宏。为了使插件管理更加方便，按照库名加上“Factory”的方式命名您的出厂头文件。例如，以下代码是与 MyPlugin.lib 相关联的 MyPluginFactory.h 的内容。

[AK\_STATIC\_LINK\_PLUGIN](_i_ak_plugin_8h_a8e9fc150137c878499f2200e7e27a256.html#a8e9fc150137c878499f2200e7e27a256)(MyPlugin); //此宏在声音引擎中注册插件。

使用 MyPlugin 的游戏仅包含 MyPluginFactory 文件，并与 MyPlugin.lib 链接。

#include <AK/Plugin/MyPluginFactory.h> // 出厂头文件强制通过 AK\_STATIC\_LINK\_PLUGIN 链接插件代码。

|  |  |
| --- | --- |
|  | **备注:** 如果您收到符号结尾定义了多重 *\_linkonceonly* 的链接错误，这意味着您在多个 .cpp 文件中加入了 Factory include。每个链接单元（如 DLL、so、dylib、exe 等）中只需加入一次。 |

# 创建动态库

在游戏中使用插件的方式分为两种：一是通过静态库，二是通过动态库。静态库是必须要发布的。动态库则不强制发布，但强烈建议发布动态库，因为[Unity](https://www.audiokinetic.com/library/?source=Unity&id=pg__building.html#sect_build_desc)中集成Wwise使用的是动态库。但是Wwise Unreal集成需要使用静态库。

使用静态库来创建动态库极其容易。Audiokinetic 对所有效果器插件都通过静态库创建了动态库，因此您可以在文件夹 `\SDK\samples\DynamicLibraries` 中找到大量的示例。您必须：

- 保证工程与您构建的静态库链接。
- 直接或者通过头文件加入 AK\_STATIC\_LINK\_PLUGIN 的引用。
- 确保您的动态库导出符号“g\_pAKPluginList”。大多数平台将自动导出此符号，因为它被显性地声明为可导出符号。有时需要显性 DEF 文件。使用宏 `DEFINE_PLUGIN_REGISTER_HOOK` 定义符号。
- 根据您的 XML 声明对动态库命名。如果您未在 XML 中指定 `EngineDllName` 属性，则以 XML 的名称对它命名。 注意，您可以把多个插件组合到一个 DLL 中。

简单来说，只需使用以下代码便可将静态库转换为动态库：

#include <[AK/SoundEngine/Common/IAkPlugin.h](_i_ak_plugin_8h.html)>

[AK\_STATIC\_LINK\_PLUGIN](_i_ak_plugin_8h_a8e9fc150137c878499f2200e7e27a256.html#a8e9fc150137c878499f2200e7e27a256)(MyPlugin);

[DEFINE\_PLUGIN\_REGISTER\_HOOK](_i_ak_plugin_8h_a0e58fa7b5f9d73031a83e4667c6f8933.html#a0e58fa7b5f9d73031a83e4667c6f8933);

要在 Unity 中部署您的插件，请在 Wwise\Deployment\Plugins\[Platform]\DSP 文件夹中放置一份动态库 。位于该文件夹中的所有 DSP 插件应采用优化过的构建配置，这样才可以供发布版的游戏使用。

|  |  |
| --- | --- |
|  | **备注:** 在 **iOS** 中，构建系统阻止使用动态库 。因此在 Unity 中，您必须部署 .a 文件和相应的 Factory.h 文件。其它平台上使用的动态库与在 iOS 中使用的静态库之间的链接通过名称来完成：确保 DLL 名称与库名称（或子字符串）相同，不带“lib”前缀。 例如：  - 在 Windows 中：MyPlugin.dll - 在 iOS 中：libMyPlugin.a + MyPluginFactory.h |

|  |  |
| --- | --- |
|  | **备注:** 在 **Mac** 中，Wwise 将只加载 DYLIB 文件。然而，Unity 不将 DYLIB 视为有效的扩展名。因此在创建游戏时，它不会复制和部署这些文件。解决这一问题的方法是，把扩展名重命名为 BUNDLE，即使文件本身不是 BUNDLE。 例如：  - 在 Windows 中：MyPlugin.dll - 在 Mac（非 Unity 游戏）：MyPlugin.dylib - 在 Mac（Unity 游戏）：MyPlugin.bundle |

|  |  |
| --- | --- |
|  | **备注:** 在**Android**中，您需要给动态库加“lib”前缀，比如libMyPlugin.so。 |

## Loading Dynamic Library Plug-ins

Unlike statically linked plug-ins, dynamically linked plug-ins are loaded on demand. The Init bank contains a list of plug-in IDs that the project uses. When the Init bank is being loaded, the Sound Engine searches this list for unrecognized plug-in IDs. An attempt to load the dynamic library that contains the plug-in is made for each of these unrecognized plug-ins.

For the attempt to succeed, the plug-in library file must be placed in a location that the operating system's dynamic library loader searches. Library search paths vary from system to system. On several platforms, the directory containing the game executable is part of the library search paths.

Alternatively, set `AkInitSettings::szPluginDLLPath` to the local system path that contains the plug-in library files. This path takes precedence over the operating system's library search paths. Refer to the IntegrationDemo sample code for the recommended `AkInitSettings::szPluginDLLPath` setup method for various platforms.

|  |  |
| --- | --- |
|  | **备注:** When using a game engine integration, `AkInitSettings::szPluginDLLPath` is managed automatically. Plug-in library files are automatically copied to the appropriate directory when Wwise is integrated into the game engine project. If you are using Unity, refer to [Integrating Wwise into a Unity Project](https://www.audiokinetic.com/library/wwise_launcher/?source=InstallGuide&id=integrating_wwise_into_a_unity_project). If you are using Unreal Engine, refer to [Integrating Wwise into an Unreal Engine Project](https://www.audiokinetic.com/library/wwise_launcher/?source=InstallGuide&id=integrating_wwise_into_an_unreal_project). |

# 在音频插件中分配/取消分配内存

您应通过提供的内存分配器接口来执行音频插件中的所有动态内存分配或取消分配。这样可确保 Memory Manager 能够追踪插件占用和释放的所有内存，并将其标记为特定内存类别，同时显示在 Wwise 性能分析器中。

提供了用于重载 new / delete 操作和使用随附的内存分配器调用 malloc() / free() 的宏。这些宏由 [IAkPluginMemAlloc.h](_i_ak_plugin_mem_alloc_8h.html) 提供。

要分配对象，则需使用 [AK\_PLUGIN\_NEW()](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479) 宏，并将指针传递到内存分配器接口和期望的对象类型。宏返回指向新分配对象的指针。需要使用相应的 [AK\_PLUGIN\_DELETE()](_i_ak_plugin_mem_alloc_8h_ac6fa6544d3120811e155136866fc24aa.html#ac6fa6544d3120811e155136866fc24aa) 宏来释放内存。

要分配数组，则要使用 [AK\_PLUGIN\_ALLOC()](_i_ak_plugin_mem_alloc_8h_abf61bf0827a987e8799a75a4d0e2f615.html#abf61bf0827a987e8799a75a4d0e2f615)，后者从 Memory Manager 获取请求的大小（单位：比特）并将空指针返回给分配的内存地址。使用相应的 [AK\_PLUGIN\_FREE()](_i_ak_plugin_mem_alloc_8h_a37dac3dbf976521288ecb8f36a16af3a.html#a37dac3dbf976521288ecb8f36a16af3a) 宏释放分配的内存。以下例程演示如何使用这些宏。

// 分配一个 CAkMyObject

CAkMykObject \* pSingleObject = [AK\_PLUGIN\_NEW](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479)( in\_pAllocator, CAkMyObject );

// 释放 pSingleObject

[AK\_PLUGIN\_DELETE](_i_ak_plugin_mem_alloc_8h_ac6fa6544d3120811e155136866fc24aa.html#ac6fa6544d3120811e155136866fc24aa)( in\_pAllocator, pSingleObject );

// 分配一系列 uNumSamples 音频样本

[AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb) \* pData = static\_cast<[AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb) \*>( [AK\_PLUGIN\_ALLOC](_i_ak_plugin_mem_alloc_8h_abf61bf0827a987e8799a75a4d0e2f615.html#abf61bf0827a987e8799a75a4d0e2f615)( in\_pAllocator, sizeof([AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb)) \* uNumSamples) );

// 释放一系列音频样本

[AK\_PLUGIN\_FREE](_i_ak_plugin_mem_alloc_8h_a37dac3dbf976521288ecb8f36a16af3a.html#a37dac3dbf976521288ecb8f36a16af3a)( in\_pAllocator, pData );

# 参数节点接口的实现

参数节点在本质上集中了参数的读写访问权限。插件参数接口包括以下方法：

## AK::IAkPluginParam::Clone()

此方法应该会创建一份完全相同的参数，并调整必要的内部状态变量，以便随时供新插件使用。例如，当事件创建新播放实例时，就会发生这种情况。此函数必须使用 [AK\_PLUGIN\_NEW()](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479) 宏返回新的参数节点。在许多情况下，调用拷贝构造函数就够了（如下面的例程中所示）。如果在参数节点中分配内存，则应执行深度复制。

// 创建相同的共享参数。

[AK::IAkPluginParam](class_a_k_1_1_i_ak_plugin_param.html) \* CAkMyPluginParams::Clone( [AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator )

{

return [AK\_PLUGIN\_NEW](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479)( in\_pAllocator, CAkMyPluginParams(\*this) );

}

## AK::IAkPluginParam::Init()

[此函数使用提供的参数块对参数进行初始化。当提供的参数块大小为零（即当设计工具中使用此插件时），AK::IAkPluginParam::Init()](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8) 应使用默认值对参数结构进行初始化。

|  |  |
| --- | --- |
|  | **技巧:**当参数块有效时，调用 [AK::IAkPluginParam::SetParamsBlock()](class_a_k_1_1_i_ak_plugin_param_ae186f2f0aa56fe0e52ab1c2218df2c7c.html#ae186f2f0aa56fe0e52ab1c2218df2c7c) 对参数块进行初始化。 |

// 参数节点初始化。

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) [CAkMyPluginParams::Init](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8)( [AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator, void \* in\_pParamsBlock, [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_ulBlockSize )

{

if ( in\_ulBlockSize == 0)

{

// 如果我们收到无效参数块，则使用默认值进行初始化。

return [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e);

}

return SetParamsBlock( in\_pParamsBlock, in\_ulBlockSize );

}

## AK::IAkPluginParam::SetParamsBlock()

此方法使用在 Wwise 中创建 SoundBank 期间通过 [AK::Wwise::Plugin::AudioPlugin::GetBankParameters()](class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_audio_plugin_ae59a3955718ed3bbde0521da21cd8539.html#ae59a3955718ed3bbde0521da21cd8539 "Obtains parameters that will be written to a bank.") 存储的参数块一次性地设置全部插件参数。插件的 Wwise 设计工具版本将按照写入 SoundBank 的同一格式读取参数。注意，数据为压缩格式，因此根据某些目标平台所需的数据类型，可能无法对齐变量。使用 [AkBankReadHelpers.h](_ak_bank_read_helpers_8h.html) 中提供的 READBANKDATA 助手宏来避免这些与特定平台相关的问题。无需担心插件参数的字节顺序问题，因为应用程序已经正确地交换数据的字节。

// 读取并解析参数块。

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) CAkMyPluginParams::SetParamsBlock( void \* in\_pParamsBlock, [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_uBlockSize )

{

// Read data in the order it was put in the bank

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) eResult = [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e);

[AkUInt8](_ak_numeral_types_8h_a6a754f6e0ddd97ae59f3aae854cde270.html#a6a754f6e0ddd97ae59f3aae854cde270) \* pParamsBlock = ([AkUInt8](_ak_numeral_types_8h_a6a754f6e0ddd97ae59f3aae854cde270.html#a6a754f6e0ddd97ae59f3aae854cde270) \*)in\_pParamsBlock;

m\_fFloatParam1 = [READBANKDATA](_ak_bank_read_helpers_8h_a18513ab855bc8316634d74b9a17138c5.html#a18513ab855bc8316634d74b9a17138c5)( [AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98), pParamsBlock, in\_ulBlockSize );

m\_bBoolParam2 = [READBANKDATA](_ak_bank_read_helpers_8h_a18513ab855bc8316634d74b9a17138c5.html#a18513ab855bc8316634d74b9a17138c5)( bool, pParamsBlock, in\_ulBlockSize );

[CHECKBANKDATASIZE](_ak_bank_read_helpers_8h_a50c3e7712a0452bd3ee8d5ac2185d2cf.html#a50c3e7712a0452bd3ee8d5ac2185d2cf)( in\_ulBlockSize, eResult );

return eResult;

}

## AK::IAkPluginParam::SetParam()

此方法一次更新一个参数。每当参数值发生变化时都会调用此方法，有的从插件 UI 调用，有的从 RTPC 调用，等等。要更新的参数由类型为 AkPluginParamID 的参数指定，对应于 Wwise XML 插件描述文件中定义的 AudioEnginePropertyID。（请参阅 [Wwise 插件 XML 描述文件](plugin_xml.html) 了解更多信息）。

|  |  |
| --- | --- |
|  | **技巧:**我们建议将 XML 文件中定义的每个 AudioEngineParameterID 绑定到 AkPluginParamsID 类型的常变量。 |

|  |  |
| --- | --- |
|  | **备注:** 无论 XML 文件中指定的属性类型，支持 RTPC 的参数被赋于 AkReal32 类型。 |

// Wwise 的参数 ID 或 RTPC。

static const [AkPluginParamID](_ak_typedefs_8h_a4cb8ff0b7014efdaa21697f4ef928926.html#a4cb8ff0b7014efdaa21697f4ef928926) AK\_MYFLOATPARAM1\_ID = 0;

static const [AkPluginParamID](_ak_typedefs_8h_a4cb8ff0b7014efdaa21697f4ef928926.html#a4cb8ff0b7014efdaa21697f4ef928926) AK\_MYBOOLPARAM2\_ID = 1;

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) CAkMyPluginParams::SetParam( [AkPluginParamID](_ak_typedefs_8h_a4cb8ff0b7014efdaa21697f4ef928926.html#a4cb8ff0b7014efdaa21697f4ef928926) in\_ParamID, void \* in\_pValue, [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_uParamSize )

{

// 设置参数值。

switch ( in\_ParamID )

{

case AK\_MYFLOATPARAM1\_ID:

m\_fFloatParam1.fParam2 = \*([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\*)( in\_pValue );

break;

case AK\_MYBOOLPARAM2\_ID:

m\_bBoolParam2 = \*(bool\*)( in\_pValue ); // 参数不支持 RTPC

or ...

// Note RTPC parameters are always of type float regardless of property type in XML plugin description

m\_bBoolParam2 = (\*([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\*)(in\_pValue)) != 0;

break;

default:

return [AK\_InvalidParameter](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a94ab17d09b6d684fa77c083126157b1d);

}

return [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e);

}

|  |  |
| --- | --- |
|  | **备注:** 若使用了 [复杂属性](plugin_backend_model.html#wwiseplugin_complexproperty)，则须在 `AK::IAkPluginParam::SetParam` 和 `AK::Wwise::Plugin::CustomData::GetPluginData` 中处理 `AK::IAkPluginParam::ALL_PLUGIN_DATA_ID` 。 该 ID 至少要在首次运行插件时使用一次。 |

## AK::IAkPluginParam::Term()

当终止参数节点时，声音引擎将调用此方法。必须释放使用的任何内存资源，参数节点负责自行析构。

// 终止共享参数。

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) [CAkMyPluginParams::Term](namespace_a_k_1_1_comm_a94e307d2974b89cc4fbc8ab0fef20d2f.html#a94e307d2974b89cc4fbc8ab0fef20d2f)( [AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator )

{

[AK\_PLUGIN\_DELETE](_i_ak_plugin_mem_alloc_8h_ac6fa6544d3120811e155136866fc24aa.html#ac6fa6544d3120811e155136866fc24aa)( in\_pAllocator, this );

return [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e);

}

## 参数节点与插件之间的通信。

每个插件都有一个相关联的参数节点，插件可以从中获取参数值，相应的更新其 DSP。相关联的参数节点接口在插件初始化时传入，在插件的生命期间将一直保持有效。然后插件可以根据 DSP 处理的需要频繁地从参数节点中查询信息。由于插件与其相关联的参数节点之间为单向关系，因此要响应参数节点对参数值的查询，则要由实现方自主处理（例如使用访问器方法）。

# 音频插件接口的实现

要开发音频插件，必须实现特定函数，以让插件能够在引擎的音频数据流中正常工作。对于源插件，您应该继承 [AK::IAkSourcePlugin](class_a_k_1_1_i_ak_source_plugin.html "Wwise sound engine source plug-in interface (see 创建声音引擎源插件).") 接口，对于可将输入缓冲区替换成输出的效果器（例如无需无序访问或改变数据速率），您应该继承 AK::IAkInPlaceEffectPlugin。对于需要实现非就地方法的其它效果器，您应继承 [AK::IAkOutOfPlaceEffectPlugin](class_a_k_1_1_i_ak_out_of_place_effect_plugin.html "Software effect plug-in interface for out-of-place processing (see 创建声音引擎效果器插件).") 接口。

A plug-in life cycle always begins with a call to one of the [AK::IAkAudioDeviceEffectPlugin::Init()](class_a_k_1_1_i_ak_audio_device_effect_plugin_ac2b7ed06052a176e4445b743e7b3dfe7.html#ac2b7ed06052a176e4445b743e7b3dfe7), [AK::IAkEffectPlugin::Init()](class_a_k_1_1_i_ak_effect_plugin_ae5a44837c4adddf6ff58fab57453b020.html#ae5a44837c4adddf6ff58fab57453b020), [AK::IAkSinkPluginBase::Init()](class_a_k_1_1_i_ak_sink_plugin_base_ab13c519292782b8e485912cb85506f25.html#ab13c519292782b8e485912cb85506f25) or [AK::IAkSourcePlugin::Init()](class_a_k_1_1_i_ak_source_plugin_a101429095bd300db35cb0795254a9a53.html#a101429095bd300db35cb0795254a9a53) functions, immediately followed by a call to [AK::IAkPlugin::Reset()](class_a_k_1_1_i_ak_plugin_a08c841c8b811acb993acd0353bd9db75.html#a08c841c8b811acb993acd0353bd9db75). 只要插件需要输出更多数据，就会使用新的缓冲区调用 AK::IAkPlugin::Execute()。当不再需要插件时调用 [AK::IAkPlugin::Term()](class_a_k_1_1_i_ak_plugin_a29db8d2afc4fe2571c2c75deb00a359d.html#a29db8d2afc4fe2571c2c75deb00a359d)。

## AK::IAkPlugin::Term()

[在终止插件时调用此方法。AK::IAkPlugin::Term()](namespace_a_k_1_1_comm_a94e307d2974b89cc4fbc8ab0fef20d2f.html#a94e307d2974b89cc4fbc8ab0fef20d2f) 必须释放插件所使用的所有内存资源，并自行析构插件。

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) [CAkMyPlugin::Term](namespace_a_k_1_1_comm_a94e307d2974b89cc4fbc8ab0fef20d2f.html#a94e307d2974b89cc4fbc8ab0fef20d2f)( [AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator )

{

if ( m\_pMyDelayLine != NULL )

{

[AK\_PLUGIN\_FREE](_i_ak_plugin_mem_alloc_8h_a37dac3dbf976521288ecb8f36a16af3a.html#a37dac3dbf976521288ecb8f36a16af3a)( in\_pAllocator, m\_pMyDelayLine );

m\_pMyDelayLine = NULL;

}

[AK\_PLUGIN\_DELETE](_i_ak_plugin_mem_alloc_8h_ac6fa6544d3120811e155136866fc24aa.html#ac6fa6544d3120811e155136866fc24aa)( in\_pAllocator, this );

return [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e);

}

## AK::IAkPlugin::Reset()

复位方法必须重新初始化插件的状态，使它准备接纳新的无关音频内容。声音引擎管线将在初始化刚结束后和任何对象状态需要复位的时刻立即调用 [AK::IAkPlugin::Reset()](class_a_k_1_1_i_ak_plugin_a08c841c8b811acb993acd0353bd9db75.html#a08c841c8b811acb993acd0353bd9db75)。一般所有内存分配都要在初始化时执行，但是在调用 [AK::IAkPlugin::Reset()](class_a_k_1_1_i_ak_plugin_a08c841c8b811acb993acd0353bd9db75.html#a08c841c8b811acb993acd0353bd9db75) 时应清除例如延迟线状态和采样点计数。

// 复位插件的内部状态

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) [CAkMyPlugin::Reset](namespace_a_k_1_1_comm_af3d99fab833c0b3c4bc7ce7b78d7b4bf.html#af3d99fab833c0b3c4bc7ce7b78d7b4bf)( )

{

// 复位延迟线

if ( m\_pMyDelayLine != NULL )

memset( m\_pMyDelayLine, 0, m\_uNumDelaySamples \* sizeof([AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb)) );

return [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e);

}

## AK::IAkPlugin::GetPluginInfo()

当声音引擎需要有关插件的信息时，要使用此插件信息查询机制。在 [AkPluginInfo](struct_ak_plugin_info.html) 结构中填写正确的信息，以描述所实现的插件类型（例如源插件或效果器插件）、它的缓冲区使用方案（例如就地使用）和处理模式（例如同步）。

|  |  |
| --- | --- |
|  | **备注:** 在所有其它平台上效果器插件应该是同步的。  // 声音引擎查询效果信息。  [AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) CAkMyPlugin::GetPluginInfo( [AkPluginInfo](struct_ak_plugin_info.html) & out\_rPluginInfo )  {  out\_rPluginInfo.[eType](struct_ak_plugin_info_a3ba9f6803016c5467ea437cb921214c5.html#a3ba9f6803016c5467ea437cb921214c5) = [AkPluginTypeSource](_ak_enums_8h_af1a95e76b0e2a003e7edb2ad6f4043f4.html#af1a95e76b0e2a003e7edb2ad6f4043f4a49c271d98bfaeb22fd40e522ba77685f); // 源插件。  out\_rPluginInfo.[bIsInPlace](struct_ak_plugin_info_a70fb541431bdc08cdb490a926ccc3ee4.html#a70fb541431bdc08cdb490a926ccc3ee4) = true; // In-place 插件。  out\_rPluginInfo.bIsAsynchronous = false; // 同步插件。  return [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e);  } |

# 访问使用 AkAudioBuffer 结构的数据

在执行时音频数据缓冲区通过指向 [AkAudioBuffer](class_ak_audio_buffer.html) 结构的指针传递给插件。传递给插件的所有音频缓冲区使用固定格式。对于支持软件效果器的平台，音频缓冲区的声道不是交错存取的，所有样本在 (-1.f,1.f) 范围为归一化 32 位浮点，以 48 kHz 采样率运行。

[AkAudioBuffer](class_ak_audio_buffer.html) 结构提供可访问交错存取和非交错存取数据的手段。It contains a field to specify the number of sample frames valid in each channel buffer ([AkAudioBuffer::uValidFrames](class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd "Number of valid sample frames in the audio buffer")) along with the maximum number of sample frames that these buffers can contain (returned by [AkAudioBuffer::MaxFrames()](class_ak_audio_buffer_a537445dce6e3ed09dd2c337fd73c6b41.html#a537445dce6e3ed09dd2c337fd73c6b41)).

[AkAudioBuffer](class_ak_audio_buffer.html) 结构还包含缓冲区的声道掩码，此掩码定义数据中存在的声道。如果您仅需要声道数，则使用 [AkAudioBuffer::NumChannels()](class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f "Get the number of channels.")。

## 获取交错存取数据。

插件可通过 [AkAudioBuffer::GetInterleavedData()](class_ak_audio_buffer_a8b3f75d4e95d5ce9af0b4573fae87510.html#a8b3f75d4e95d5ce9af0b4573fae87510) 访问交错存取数据的缓冲区。Only source plug-ins should access and output interleaved data. 为了做到这一点，它们必须在初始化期间正确准备声音引擎（请参阅 [AK::IAkSourcePlugin::Init()](soundengine_plugins_source.html#iaksourceeffect_init) ）。声音引擎将处理的 DSP 实例化，以正确地把数据转换成内建管线格式。

|  |  |
| --- | --- |
|  | **技巧:** 如果源插件输出数据本来符合声音引擎的内建格式，您则可以获得更高的性能。 |

## 获取非交错存取数据。

插件通过 [AkAudioBuffer::GetChannel()](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c) 访问单个非交错存取声道。The data type always conforms to the sound engine's native format (AkSampleType). 以下例程显示如何获取所有非交错存取声道进行处理。

// 各自处理所有声道。

void CAkMyPlugin::Execute( [AkAudioBuffer](class_ak_audio_buffer.html) \* io\_pBuffer ) // 输入/输出缓冲区（现场执行处理）。

{

[AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) uNumChannels = io\_pBuffer->[NumChannels](class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f)();

for ( [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) uChan=0; uChan<uNumChannels; uChan++ )

{

[AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb) \* pChannel = io\_pBuffer->[GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)( uChan );

// Process data of pChannel...

}

}

|  |  |
| --- | --- |
|  | **注意:** 插件决不可想当然地认为每个声道的缓冲区在内存中是连续的。 |

## 声道顺序

声道排序如下：Front Left（左前）、Front Right（右前）、Center（中置）、Rear Left（左后）、Rear Right（右后），和 LFE。低频声道（LFE）**总是**布置在末尾，这是因为很多 DSP 运算需要单独来处理 LFE。插件可以使用 `AkAudioBuffer::HasLFE()` 来查询音频缓冲区中是否存在 LFE 声道。它可以通过调用 `AkAudioBuffer::GetLFE()` 直接访问 LFE 声道。以下代码演示独立处理 LFE 声道的两种不同方式。

void CAkMyPlugin::Execute( [AkAudioBuffer](class_ak_audio_buffer.html) \* io\_pBuffer ) // 输入/输出缓冲区（现场执行处理）。

{

// 使用 GetLFE() 获取 LFE 声道。

[AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb) \* pLFE = io\_pBuffer->[GetLFE](class_ak_audio_buffer_a06f9e3184b8664df136f8d123b04cc81.html#a06f9e3184b8664df136f8d123b04cc81)();

if ( pLFE )

{

// 处理 pLFE 的数据……

}

OR ...

// 通过 GetChannel() 获取 LFE。

if ( io\_pBuffer->[HasLFE](class_ak_audio_buffer_a9ac12a3c62e9c1e734b5a42d68896bf4.html#a9ac12a3c62e9c1e734b5a42d68896bf4)() )

{

[AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb) \* pLFE = io\_pBuffer->[GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)( io\_pBuffer->[NumChannels](class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f)() - 1 );

// 处理 pLFE 的数据……

}

}

如果您要对非 LFE 的声道做特定处理，则需要使用 [AkCommonDefs.h](_ak_common_defs_8h.html) 的声道索引定义。 例如，如果您想只处理 5.x 配置的中置声道，则要执行以下操作：

// 只处理 5.x 配置的中置声道。

void CAkMyPlugin::Execute( [AkAudioBuffer](class_ak_audio_buffer.html) \* io\_pBuffer ) // 输入/输出缓冲区（现场执行处理）。

{

// 查询特定声道配置。

if ( io\_pBuffer->GetChannelMask() == [AK\_SPEAKER\_SETUP\_5](_ak_speaker_config_8h_af181b7b2236165b1e43fc8d54f5dee9d.html#af181b7b2236165b1e43fc8d54f5dee9d) || io\_pBuffer->GetChannelMask() == [AK\_SPEAKER\_SETUP\_5POINT1](_ak_speaker_config_8h_a666b8c74f7cca22244ae5d96b6a665e0.html#a666b8c74f7cca22244ae5d96b6a665e0) )

{

// 使用为相应配置定义的索引访问声道。

[AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb) \* pCenter = io\_pBuffer->[GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)( [AK\_IDX\_SETUP\_5\_CENTER](_ak_speaker_config_8h_a2639ea7a4d6c2a1a0fa9368ef9d15f33.html#a2639ea7a4d6c2a1a0fa9368ef9d15f33) );

// 处理 pCenter 的数据……

}

}

|  |  |
| --- | --- |
|  | **技巧:** 注意，声道索引定义与配置是 N.0 还是 N.1 无关。This is because the LFE channel is always the last one, except for Source plug-ins (AK\_IDX\_SETUP\_N\_LFE should not be used if the channel configuration has no LFE). |

|  |  |
| --- | --- |
|  | **备注:** 在7.1的情况下，源插件交错数据的声道顺序是 L-R-C-LFE-BL-BR-SL-SR。 |

# 在插件中使用全局声音引擎回调

插件可使用 `AK::IAkGlobalPluginContext::RegisterGlobalCallback()` 注册到各个全局声音引擎回调。例如，对于每个音频帧，可能需要通过插件知道的 Singleton（单例）对象调用一次插件类。您还可使用全局挂钩来初始化在声音引擎整个生命期间一直保留的数据结构。

为此，将默认的 AK\_IMPLEMENT\_PLUGIN\_FACTORY 宏替换为您自己的实现，以利用 [AK::PluginRegistration](class_a_k_1_1_plugin_registration.html) 的“RegisterCallback”。下面的代码片段中为此定义了一个静态回调 MyRegisterCallback，并将它传递给 [AK::PluginRegistration](class_a_k_1_1_plugin_registration.html) 对象 MyPluginRegistration。

|  |  |
| --- | --- |
|  | **备注:** `AK_IMPLEMENT_PLUGIN_FACTORY` 宏声明出厂函数和 `AK::PluginRegistration` 对象，将字符串附加到插件名称后面，名称是作为参数传递给它的。在下例中，`AK_IMPLEMENT_PLUGIN_FACTORY` 已按照相同的命名规则重新实现了。对于您自己的插件，应将“MyPlugin”替换成插件的实际名称。另外，`AK_IMPLEMENT_PLUGIN_FACTORY` 的姊妹宏 `AK_STATIC_LINK_PLUGIN` 遵循相同的命名规则。如果您没采用 `AK_IMPLEMENT_PLUGIN_FACTORY` 的命名规则，则还需要相应地重新实现 `AK_STATIC_LINK_PLUGIN` 。 |

|  |  |
| --- | --- |
|  | **注意:** 在接收 `AkGlobalCallbackLocation::AkGlobalCallbackLocation_Register` 时，仅允许从插件注册回调内调用 `AK::IAkGlobalPluginContext::RegisterGlobalCallback()` ；在接收 `AkGlobalCallbackLocation::AkGlobalCallbackLocation_Term` 时，仅允许调用 `AK::IAkGlobalPluginContext::UnregisterGlobalCallback()` 。 确切地说，就是不可从插件实例（如 Init、Execute 等）内调用此函数，以免在并行处理插件时发生死锁。 |

// 用于初始化和终止 MyPluginManager (AkGlobalCallbackFunc) 的全局回调。

static void MyRegisterCallback(

[AK::IAkGlobalPluginContext](class_a_k_1_1_i_ak_global_plugin_context.html) \* in\_pContext, ///< 引擎上下文。

[AkGlobalCallbackLocation](_ak_callback_types_8h_ae7a5e30e1402c7cf90d1b47420911676.html#ae7a5e30e1402c7cf90d1b47420911676) in\_eLocation, ///< 启动此回调的位置。

void \* in\_pCookie ///< 用户 cookie 传递到 AK::SoundEngine::RegisterGlobalCallback()。

)

{

if (in\_eLocation == [AkGlobalCallbackLocation\_Register](_ak_callback_types_8h_ae7a5e30e1402c7cf90d1b47420911676.html#ae7a5e30e1402c7cf90d1b47420911676a68917ce14320bb481b9ab2cfe6b228b6))

{

// 注册时间：在声音引擎初始化或动态插件库加载时调用。

// 创建我们的单例模式。对于应该跨越声音引擎整个生命周期的分配，要使用全局上下文提供的分配器。

MyPluginManager \* pMyPluginManager = [AK\_PLUGIN\_NEW](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479)(in\_pContext->[GetAllocator](class_a_k_1_1_i_ak_global_plugin_context_a9856698ca2c6d1897b7c871e259b93aa.html#a9856698ca2c6d1897b7c871e259b93aa)(), MyPluginManager);

if (pMyPluginManager)

{

// 已成功。注册到“Term”回调来终止我们的管理器。

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) eResult = in\_pContext->[RegisterGlobalCallback](class_a_k_1_1_i_ak_global_plugin_context_a1cbd90dbcb3c0e69a8c80fd4aefc822c.html#a1cbd90dbcb3c0e69a8c80fd4aefc822c)(

[AkPluginTypeEffect](_ak_enums_8h_af1a95e76b0e2a003e7edb2ad6f4043f4.html#af1a95e76b0e2a003e7edb2ad6f4043f4a2971cc4c818bf62c55175445d2be117d),

MY\_COMPANY\_ID,

MY\_PLUGIN\_ID,

MyRegisterCallback,

[AkGlobalCallbackLocation\_Term](_ak_callback_types_8h_ae7a5e30e1402c7cf90d1b47420911676.html#ae7a5e30e1402c7cf90d1b47420911676aa5c7eebdf589a1b0ea29989e78e8ea2d),

pMyPluginManager

);

// Handle registration failure.

if (eResult != [AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e))

{

// ...

}

}

}

else if (in\_eLocation == [AkGlobalCallbackLocation\_Term](_ak_callback_types_8h_ae7a5e30e1402c7cf90d1b47420911676.html#ae7a5e30e1402c7cf90d1b47420911676aa5c7eebdf589a1b0ea29989e78e8ea2d))

{

// 终止时间：在声音引擎终止时调用。

// cookie 是在上面注册的 MyPluginManager 的实例。

[AKASSERT](_ak_assert_8h_ac0e6cc4061c0a7c154a8c921a0af74cb.html#ac0e6cc4061c0a7c154a8c921a0af74cb)(in\_pCookie);

// 销毁它。

[AK\_PLUGIN\_DELETE](_i_ak_plugin_mem_alloc_8h_ac6fa6544d3120811e155136866fc24aa.html#ac6fa6544d3120811e155136866fc24aa)(in\_pContext->[GetAllocator](class_a_k_1_1_i_ak_global_plugin_context_a9856698ca2c6d1897b7c871e259b93aa.html#a9856698ca2c6d1897b7c871e259b93aa)(), (MyPluginManager\*)in\_pCookie);

}

}

// 替换 AK\_IMPLEMENT\_PLUGIN\_FACTORY(MyPlugin, AkPluginTypeEffect, MY\_COMPANY\_ID, MY\_PLUGIN\_ID)

// 在此，“MyPlugin”应替换成您插件的名称。

[AK::IAkPlugin](class_a_k_1_1_i_ak_plugin.html)\* CreateMyPlugin([AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator);

[AK::IAkPluginParam](class_a_k_1_1_i_ak_plugin_param.html) \* CreateMyPluginParams([AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html) \* in\_pAllocator);

[AK::PluginRegistration](class_a_k_1_1_plugin_registration.html) MyPluginRegistration([AkPluginTypeEffect](_ak_enums_8h_af1a95e76b0e2a003e7edb2ad6f4043f4.html#af1a95e76b0e2a003e7edb2ad6f4043f4a2971cc4c818bf62c55175445d2be117d), MY\_COMPANY\_ID, MY\_PLUGIN\_ID, CreateMyPlugin, CreateMyPluginParams, MyRegisterCallback, NULL);

有关更多信息，请参阅以下各节：

- [源插件接口实现](soundengine_plugins_source.html#se_source_effect)
- [实现效果器插件接口](soundengine_plugins_effects.html#se_insert_effect)
- [编写音频插件的设计工具部分](effectpluginwwise.html)

[AkAudioBuffer::HasLFE](class_ak_audio_buffer_a9ac12a3c62e9c1e734b5a42d68896bf4.html#a9ac12a3c62e9c1e734b5a42d68896bf4)

AkForceInline bool HasLFE() const

Returns true if there is an LFE channel present.

**Definition:** [AkCommonDefs.h:343](_ak_common_defs_8h_source.html#l00343)

[AK\_PLUGIN\_DELETE](_i_ak_plugin_mem_alloc_8h_ac6fa6544d3120811e155136866fc24aa.html#ac6fa6544d3120811e155136866fc24aa)

AkForceInline void AK\_PLUGIN\_DELETE(AK::IAkPluginMemAlloc \*in\_pAllocator, T \*in\_pObject)

**Definition:** [IAkPluginMemAlloc.h:178](_i_ak_plugin_mem_alloc_8h_source.html#l00178)

[AkAudioBuffer::GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)

AkSampleType \* GetChannel(AkUInt32 in\_uIndex)

**Definition:** [AkCommonDefs.h:421](_ak_common_defs_8h_source.html#l00421)

[AK\_STATIC\_LINK\_PLUGIN](_i_ak_plugin_8h_a8e9fc150137c878499f2200e7e27a256.html#a8e9fc150137c878499f2200e7e27a256)

#define AK\_STATIC\_LINK\_PLUGIN(\_pluginName\_)

**Definition:** [IAkPlugin.h:2118](_i_ak_plugin_8h_source.html#l02118)

[AkPluginTypeSource](_ak_enums_8h_af1a95e76b0e2a003e7edb2ad6f4043f4.html#af1a95e76b0e2a003e7edb2ad6f4043f4a49c271d98bfaeb22fd40e522ba77685f)

@ AkPluginTypeSource

Source plug-in: creates sound by synthesis method (no input, just output).

**Definition:** [AkEnums.h:284](_ak_enums_8h_source.html#l00284)

[AK::IAkPluginParam](class_a_k_1_1_i_ak_plugin_param.html)

**Definition:** [IAkPlugin.h:709](_i_ak_plugin_8h_source.html#l00708)

[AkAudioBuffer::NumChannels](class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f)

AkForceInline AkUInt32 NumChannels() const

Get the number of channels.

**Definition:** [AkCommonDefs.h:337](_ak_common_defs_8h_source.html#l00337)

[CHECKBANKDATASIZE](_ak_bank_read_helpers_8h_a50c3e7712a0452bd3ee8d5ac2185d2cf.html#a50c3e7712a0452bd3ee8d5ac2185d2cf)

#define CHECKBANKDATASIZE(\_DATASIZE\_, \_ERESULT\_)

Helper macro to determine whether the full content of a block of memory was properly parsed

**Definition:** [AkBankReadHelpers.h:266](_ak_bank_read_helpers_8h_source.html#l00266)

[AkGlobalCallbackLocation\_Register](_ak_callback_types_8h_ae7a5e30e1402c7cf90d1b47420911676.html#ae7a5e30e1402c7cf90d1b47420911676a68917ce14320bb481b9ab2cfe6b228b6)

@ AkGlobalCallbackLocation\_Register

Right after successful registration of callback/plugin. Typically used by plugins along with AkGlobal...

**Definition:** [AkCallbackTypes.h:110](_ak_callback_types_8h_source.html#l00110)

[AkPluginInfo::bIsInPlace](struct_ak_plugin_info_a70fb541431bdc08cdb490a926ccc3ee4.html#a70fb541431bdc08cdb490a926ccc3ee4)

bool bIsInPlace

Buffer usage (in-place or not). If true, and the plug-in is an insert effect, it should implement IAk...

**Definition:** [IAkPlugin.h:78](_i_ak_plugin_8h_source.html#l00078)

[AkUInt8](_ak_numeral_types_8h_a6a754f6e0ddd97ae59f3aae854cde270.html#a6a754f6e0ddd97ae59f3aae854cde270)

uint8\_t AkUInt8

Unsigned 8-bit integer

**Definition:** [AkNumeralTypes.h:34](_ak_numeral_types_8h_source.html#l00034)

[AK\_SPEAKER\_SETUP\_5](_ak_speaker_config_8h_af181b7b2236165b1e43fc8d54f5dee9d.html#af181b7b2236165b1e43fc8d54f5dee9d)

#define AK\_SPEAKER\_SETUP\_5

5.0 setup channel mask

**Definition:** [AkSpeakerConfig.h:72](_ak_speaker_config_8h_source.html#l00072)

[AK::Comm::Reset](namespace_a_k_1_1_comm_af3d99fab833c0b3c4bc7ce7b78d7b4bf.html#af3d99fab833c0b3c4bc7ce7b78d7b4bf)

AKSOUNDENGINE\_API AKRESULT Reset()

[AK::Comm::Init](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8)

AKSOUNDENGINE\_API AKRESULT Init(const AkCommSettings &in\_settings)

[AK\_PLUGIN\_NEW](_i_ak_plugin_mem_alloc_8h_aca786bdd3829c192297a174d5d2d2479.html#aca786bdd3829c192297a174d5d2d2479)

#define AK\_PLUGIN\_NEW(\_allocator, \_what)

**Definition:** [IAkPluginMemAlloc.h:123](_i_ak_plugin_mem_alloc_8h_source.html#l00123)

[AkGlobalCallbackLocation\_Term](_ak_callback_types_8h_ae7a5e30e1402c7cf90d1b47420911676.html#ae7a5e30e1402c7cf90d1b47420911676aa5c7eebdf589a1b0ea29989e78e8ea2d)

@ AkGlobalCallbackLocation\_Term

Sound engine termination.

**Definition:** [AkCallbackTypes.h:121](_ak_callback_types_8h_source.html#l00121)

[AK\_IMPLEMENT\_PLUGIN\_FACTORY](_i_ak_plugin_8h_a13b2972f82acec4f7cedcb073d51619c.html#a13b2972f82acec4f7cedcb073d51619c)

#define AK\_IMPLEMENT\_PLUGIN\_FACTORY(\_pluginName\_, \_plugintype\_, \_companyid\_, \_pluginid\_)

**Definition:** [IAkPlugin.h:2113](_i_ak_plugin_8h_source.html#l02113)

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)

float AkReal32

32-bit floating point

**Definition:** [AkNumeralTypes.h:43](_ak_numeral_types_8h_source.html#l00043)

[AK\_IDX\_SETUP\_5\_CENTER](_ak_speaker_config_8h_a2639ea7a4d6c2a1a0fa9368ef9d15f33.html#a2639ea7a4d6c2a1a0fa9368ef9d15f33)

#define AK\_IDX\_SETUP\_5\_CENTER

Index of center channel in 5.x setups (use with AkAudioBuffer::GetChannel())

**Definition:** [AkSpeakerConfig.h:163](_ak_speaker_config_8h_source.html#l00163)

[AkPluginParamID](_ak_typedefs_8h_a4cb8ff0b7014efdaa21697f4ef928926.html#a4cb8ff0b7014efdaa21697f4ef928926)

AkInt16 AkPluginParamID

Source or effect plug-in parameter ID

**Definition:** [AkTypedefs.h:45](_ak_typedefs_8h_source.html#l00045)

[AK::Comm::Term](namespace_a_k_1_1_comm_a94e307d2974b89cc4fbc8ab0fef20d2f.html#a94e307d2974b89cc4fbc8ab0fef20d2f)

AKSOUNDENGINE\_API void Term()

[AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html)

**Definition:** [IAkPluginMemAlloc.h:42](_i_ak_plugin_mem_alloc_8h_source.html#l00041)

[AkGlobalCallbackLocation](_ak_callback_types_8h_ae7a5e30e1402c7cf90d1b47420911676.html#ae7a5e30e1402c7cf90d1b47420911676)

AkGlobalCallbackLocation

Bit field of various locations in the audio processing loop where the game can be called back.

**Definition:** [AkCallbackTypes.h:109](_ak_callback_types_8h_source.html#l00108)

[DEFINE\_PLUGIN\_REGISTER\_HOOK](_i_ak_plugin_8h_a0e58fa7b5f9d73031a83e4667c6f8933.html#a0e58fa7b5f9d73031a83e4667c6f8933)

#define DEFINE\_PLUGIN\_REGISTER\_HOOK

**Definition:** [IAkPlugin.h:2122](_i_ak_plugin_8h_source.html#l02122)

[AK\_PLUGIN\_FREE](_i_ak_plugin_mem_alloc_8h_a37dac3dbf976521288ecb8f36a16af3a.html#a37dac3dbf976521288ecb8f36a16af3a)

#define AK\_PLUGIN\_FREE(\_allocator, \_pvmem)

**Definition:** [IAkPluginMemAlloc.h:193](_i_ak_plugin_mem_alloc_8h_source.html#l00193)

[AK::PluginRegistration](class_a_k_1_1_plugin_registration.html)

**Definition:** [IAkPlugin.h:1994](_i_ak_plugin_8h_source.html#l01993)

[AKASSERT](_ak_assert_8h_ac0e6cc4061c0a7c154a8c921a0af74cb.html#ac0e6cc4061c0a7c154a8c921a0af74cb)

#define AKASSERT(Condition)

**Definition:** [AkAssert.h:69](_ak_assert_8h_source.html#l00069)

[AkPluginInfo::eType](struct_ak_plugin_info_a3ba9f6803016c5467ea437cb921214c5.html#a3ba9f6803016c5467ea437cb921214c5)

AkPluginType eType

Plug-in type

**Definition:** [IAkPlugin.h:76](_i_ak_plugin_8h_source.html#l00076)

[AkPluginInfo](struct_ak_plugin_info.html)

**Definition:** [IAkPlugin.h:62](_i_ak_plugin_8h_source.html#l00061)

[AkSampleType](_ak_common_defs_8h_a58f11a728038d16fe4187612a7a842fb.html#a58f11a728038d16fe4187612a7a842fb)

AkReal32 AkSampleType

Audio sample data type (32 bit floating point)

**Definition:** [AkCommonDefs.h:303](_ak_common_defs_8h_source.html#l00303)

[AK\_PLUGIN\_ALLOC](_i_ak_plugin_mem_alloc_8h_abf61bf0827a987e8799a75a4d0e2f615.html#abf61bf0827a987e8799a75a4d0e2f615)

#define AK\_PLUGIN\_ALLOC(\_allocator, \_size)

**Definition:** [IAkPluginMemAlloc.h:134](_i_ak_plugin_mem_alloc_8h_source.html#l00134)

[AK\_SPEAKER\_SETUP\_5POINT1](_ak_speaker_config_8h_a666b8c74f7cca22244ae5d96b6a665e0.html#a666b8c74f7cca22244ae5d96b6a665e0)

#define AK\_SPEAKER\_SETUP\_5POINT1

5.1 setup channel mask

**Definition:** [AkSpeakerConfig.h:73](_ak_speaker_config_8h_source.html#l00073)

[READBANKDATA](_ak_bank_read_helpers_8h_a18513ab855bc8316634d74b9a17138c5.html#a18513ab855bc8316634d74b9a17138c5)

#define READBANKDATA(\_Type, \_Ptr, \_Size)

Read and return bank data of a given type, incrementing running pointer and decrementing block size f...

**Definition:** [AkBankReadHelpers.h:225](_ak_bank_read_helpers_8h_source.html#l00225)

[AkPluginTypeEffect](_ak_enums_8h_af1a95e76b0e2a003e7edb2ad6f4043f4.html#af1a95e76b0e2a003e7edb2ad6f4043f4a2971cc4c818bf62c55175445d2be117d)

@ AkPluginTypeEffect

Effect plug-in: applies processing to audio data.

**Definition:** [AkEnums.h:285](_ak_enums_8h_source.html#l00285)

[AK::IAkGlobalPluginContext](class_a_k_1_1_i_ak_global_plugin_context.html)

**Definition:** [IAkPlugin.h:1442](_i_ak_plugin_8h_source.html#l01441)

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63)

AKRESULT

**Definition:** [AkEnums.h:32](_ak_enums_8h_source.html#l00031)

[AK\_InvalidParameter](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63a94ab17d09b6d684fa77c083126157b1d)

@ AK\_InvalidParameter

Something is not within bounds, check the documentation of the function returning this code.

**Definition:** [AkEnums.h:50](_ak_enums_8h_source.html#l00050)

[AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce)

uint32\_t AkUInt32

Unsigned 32-bit integer

**Definition:** [AkNumeralTypes.h:35](_ak_numeral_types_8h_source.html#l00035)

[AK::IAkGlobalPluginContext::GetAllocator](class_a_k_1_1_i_ak_global_plugin_context_a9856698ca2c6d1897b7c871e259b93aa.html#a9856698ca2c6d1897b7c871e259b93aa)

virtual AK::IAkPluginMemAlloc \* GetAllocator()=0

Get the default allocator for plugins. This is useful for performing global initialization tasks shar...

[AkAudioBuffer](class_ak_audio_buffer.html)

**Definition:** [AkCommonDefs.h:310](_ak_common_defs_8h_source.html#l00309)

[AkAudioBuffer::GetLFE](class_ak_audio_buffer_a06f9e3184b8664df136f8d123b04cc81.html#a06f9e3184b8664df136f8d123b04cc81)

AkSampleType \* GetLFE()

**Definition:** [AkCommonDefs.h:433](_ak_common_defs_8h_source.html#l00433)

[AK\_Success](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63ad7c47fea3da641e7422573c6a13dc35e)

@ AK\_Success

The operation was successful.

**Definition:** [AkEnums.h:34](_ak_enums_8h_source.html#l00034)

[IAkPlugin.h](_i_ak_plugin_8h.html)

[AK::IAkGlobalPluginContext::RegisterGlobalCallback](class_a_k_1_1_i_ak_global_plugin_context_a1cbd90dbcb3c0e69a8c80fd4aefc822c.html#a1cbd90dbcb3c0e69a8c80fd4aefc822c)

virtual AKRESULT RegisterGlobalCallback(AkPluginType in\_eType, AkUInt32 in\_ulCompanyID, AkUInt32 in\_ulPluginID, AkGlobalCallbackFunc in\_pCallback, AkUInt32 in\_eLocation=AkGlobalCallbackLocation\_BeginRender, void \*in\_pCookie=NULL)=0

[AK::IAkPlugin](class_a_k_1_1_i_ak_plugin.html)

**Definition:** [IAkPlugin.h:780](_i_ak_plugin_8h_source.html#l00779)