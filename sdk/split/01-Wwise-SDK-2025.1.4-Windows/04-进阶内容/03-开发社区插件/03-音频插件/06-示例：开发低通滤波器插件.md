# 示例：开发低通滤波器插件

|  |
| --- |
| Wwise SDK 2025.1.4 - Windows |

示例：开发低通滤波器插件

本主题提供了详尽的社区插件开发示例。在本例中，我们会开发低通滤波器插件。

# 创建新的工程

首先，需要使用 **wp.py** 工具创建新的插件工程。有关 `new` 参数的更多详细信息，请参阅 [创建音频插件](effectplugin_tools_newplugin.html) 章节。

python "%WWISEROOT%/Scripts/Build/Plugins/wp.py" new --effect -a author\_name -n Lowpass -t "First Order Lowpass" -d "Simple First Order Lowpass Filter"

cd Lowpass

目标为 Windows 上的设计工具平台。为此，我们来调用 `premake` ：

python "%WWISEROOT%/Scripts/Build/Plugins/wp.py" premake Authoring

现在创建好了用于构建声音引擎和设计工具 (WwisePlugin) 部分的解决方案。

接下来，便可构建自研插件并确认是否能在 Wwise 中加载。

python "%WWISEROOT%/Scripts/Build/Plugins/wp.py" build -c Release -x x64 -t vc160 Authoring

# 实现滤波处理效果

现在，我们想添加一些处理效果来进一步增强插件的功能。在此，我们使用以下公式来实现简单的一阶低通滤波效果：

```
y[n] = x[n] + (y[n-1] - x[n]) * coeff
```

其中 `coeff` 浮点值介于 0 ~ 1 之间。

首先，我们在 `SoundEnginePlugin/LowpassFX.h` 中创建一组变量来保存滤波器的数据。

#include <vector>

//...

private:

//...

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) m\_coeff;

std::vector<AkReal32> m\_previousOutput;

变量 `m_coeff` 为滤波器系数。该浮点值将用于所有声道。矢量 `m_previousOutput` 将保存所有声道的上一输出值，以供计算滤波器的后续数值。

要想实现滤波效果，只需初始化系数变量，依据声道数调节矢量的大小，然后使用上述公式处理每一样本。

在 `SoundEnginePlugin/LowpassFX.cpp` 中：

LowpassFX::LowpassFX()

: //...

, m\_coeff(0.99f)

//...

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) LowpassFX::[Init](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8)([AK](namespace_a_k.html)::IAkPluginMemAlloc\* in\_pAllocator, [AK](namespace_a_k.html)::IAkEffectPluginContext\* in\_pContext, [AK](namespace_a_k.html)::IAkPluginParam\* in\_pParams, [AkAudioFormat](struct_ak_audio_format.html)& in\_rFormat)

{

//...

m\_previousOutput.resize(in\_rFormat.GetNumChannels(), 0.0f);

//...

}

void LowpassFX::Execute([AkAudioBuffer](class_ak_audio_buffer.html)\* io\_pBuffer)

{

const [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) uNumChannels = io\_pBuffer->[NumChannels](class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f)();

[AkUInt16](_ak_numeral_types_8h_a7100a9b0a3b01df7639c1dc512678219.html#a7100a9b0a3b01df7639c1dc512678219) uFramesProcessed;

for ([AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) i = 0; i < uNumChannels; ++i)

{

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* [AK\_RESTRICT](_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf) pBuf = ([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* [AK\_RESTRICT](_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf))io\_pBuffer->[GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)(i);

uFramesProcessed = 0;

while (uFramesProcessed < io\_pBuffer->uValidFrames)

{

// Apply lowpass filtering per channel.

m\_previousOutput[i] = pBuf[uFramesProcessed] =

pBuf[uFramesProcessed] + (m\_previousOutput[i] - pBuf[uFramesProcessed]) \* m\_coeff;

++uFramesProcessed;

}

}

}

# 使用 RTPC 参数来控制滤波器的频率

目前的滤波器比较简单，因为无法与之进行交互。下面我们来将 RTPC 参数与滤波器的频率绑定，以便实时更改其数值。为了允许插件使用 RTPC 参数，我们需要实施以下四项更改。

首先，必须在 `WwisePlugin/Lowpass.xml` 中添加其定义。插件模板中已经有了名为 PlaceHolder 的参数框架。 我们来使用其定义 Frequency 参数。在 `WwisePlugin/Lowpass.xml` 中，将占位属性替换为以下内容：

<Property Name="Frequency" Type="Real32" SupportRTPCType="Exclusive" DisplayName="Cutoff Frequency">

<UserInterface Step="0.1" Fine="0.001" Decimals="3" UIMax="10000" />

<DefaultValue>1000.0</DefaultValue>

<AudioEnginePropertyID>0</AudioEnginePropertyID>

<Restrictions>

<ValueRestriction>

<Range Type="Real32">

<Min>20.0</Min>

<Max>10000.0</Max>

</Range>

</ValueRestriction>

</Restrictions>

</Property>

其次，需要更新 SoundEnginePlugin 文件夹中的 `LowpassFXParams.h` 和 `LowpassFXParams.cpp` 来反映属性更改。

在 `LowpassFXParams.h` 中，更新 LowpassRTPCParams 结构中的参数 ID 和参数名称。

static const [AkPluginParamID](_ak_typedefs_8h_a4cb8ff0b7014efdaa21697f4ef928926.html#a4cb8ff0b7014efdaa21697f4ef928926) PARAM\_FREQUENCY\_ID = 0;

struct LowpassRTPCParams

{

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) fFrequency;

};

同时更新 `LowpassFXParams.cpp` ：

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) [LowpassFXParams::Init](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8)([AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html)\* in\_pAllocator, const void\* in\_pParamsBlock, [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_ulBlockSize)

{

if (in\_ulBlockSize == 0)

{

// Initialize default parameters here

RTPC.fFrequency = 1000.0f;

//...

}

//...

}

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) LowpassFXParams::SetParamsBlock(const void\* in\_pParamsBlock, [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_ulBlockSize)

{

//...

// Read bank data here

RTPC.fFrequency = [READBANKDATA](_ak_bank_read_helpers_8h_a18513ab855bc8316634d74b9a17138c5.html#a18513ab855bc8316634d74b9a17138c5)([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98), pParamsBlock, in\_ulBlockSize);

//...

}

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) LowpassFXParams::SetParam([AkPluginParamID](_ak_typedefs_8h_a4cb8ff0b7014efdaa21697f4ef928926.html#a4cb8ff0b7014efdaa21697f4ef928926) in\_paramID, const void\* in\_pValue, [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_ulParamSize)

{

//...

// Handle parameter change here

case PARAM\_FREQUENCY\_ID:

RTPC.fFrequency = \*(([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\*)in\_pValue);

//...

}

再次，在 `WwisePlugin` 文件夹中，需要更新 `Lowpass::GetBankParameters` 函数，以将 Frequency 参数写入到 SoundBank 中：

bool LowpassPlugin::GetBankParameters(const GUID & in\_guidPlatform, [AK::Wwise::Plugin::DataWriter](class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer.html)\* in\_pDataWriter) const

{

// Write bank data here

in\_pDataWriter->[WriteReal32](class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer_a8d9b58e2ecba7f95721d4b89b7f9630f.html#a8d9b58e2ecba7f95721d4b89b7f9630f)(m\_propertySet.GetReal32(in\_guidPlatform, "Frequency"));

return true;

}

最后，在处理循环中，还要使用以下公式来依据当前频率计算滤波器的系数：

```
coeff = exp(-2 * pi * f / sr)
```

我们需要检索当前采样率。

// LowpassFX.h

private:

//...

[AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) m\_sampleRate;

// LowpassFX.cpp

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) [LowpassFX::Init](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8)([AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html)\* in\_pAllocator, [AK::IAkEffectPluginContext](class_a_k_1_1_i_ak_effect_plugin_context.html)\* in\_pContext, [AK::IAkPluginParam](class_a_k_1_1_i_ak_plugin_param.html)\* in\_pParams, [AkAudioFormat](struct_ak_audio_format.html)& in\_rFormat)

{

//...

m\_sampleRate = in\_rFormat.[uSampleRate](struct_ak_audio_format_ad94d7b21266cb1d8a9aa5557f875d0fa.html#ad94d7b21266cb1d8a9aa5557f875d0fa);

//...

}

加入一些数学符号。

// LowpassFX.cpp

#include <cmath>

#ifndef M\_PI

#define M\_PI 3.14159265359

#endif

//...

计算滤波器系数：

// LowpassFX.cpp

void LowpassFX::Execute([AkAudioBuffer](class_ak_audio_buffer.html)\* io\_pBuffer)

{

m\_coeff = static\_cast<[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)>(exp(-2.0 \* M\_PI \* m\_pParams->RTPC.fFrequency / m\_sampleRate));

//...

}

# 插入参数值

通常，每个缓冲区大小更新一次处理参数是不够的（缓冲区大小等于声道缓冲区中的采样数，一般介于 64 ~ 2048 之间）。尤其是在此参数会影响处理的频率或增益的情况下，数值更新太慢会导致输出声音中出现拉链噪声或噼啪噪声。

对此，只需在整个缓冲区当中以线性方式插入数值即可。下面我们来针对频率参数执行此操作。

在计算一帧新的音频样本之前（即在 `LowpassFX.cpp` 中的 `Execute` 函数最上面），我们要检查频率参数是否发生了更改。 为此，可直接查询 `LowpassFXParams` 类中的 `AkFXParameterChangeHandler` 对象。若频率发生了更改，则计算 ramp 的变量：

|  |  |
| --- | --- |
|  | **备注:** `AkAudioBuffer` 对象的成员变量 `uValidFrames` 代表缓冲区中每个声道所含的有效采样数。 |

void LowpassFX::Execute([AkAudioBuffer](class_ak_audio_buffer.html)\* io\_pBuffer)

{

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) coeffBegin = m\_coeff, coeffEnd = 0.0f, coeffStep = 0.0f;

if (m\_pParams->m\_paramChangeHandler.HasChanged(PARAM\_FREQUENCY\_ID))

{

coeffEnd = static\_cast<[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)>(exp(-2.0 \* M\_PI \* m\_pParams->RTPC.fFrequency / m\_sampleRate));

coeffStep = (coeffEnd - coeffBegin) / io\_pBuffer->[uValidFrames](class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd);

}

//...

}

在获取该数据后，只需每帧将 `coeffBegin` 增大 `coeffStep` 即可。我们需要针对输入/输出缓冲区的每个声道执行此操作。

void LowpassFX::Execute([AkAudioBuffer](class_ak_audio_buffer.html)\* io\_pBuffer)

{

//...

for ([AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) i = 0; i < uNumChannels; ++i)

{

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* [AK\_RESTRICT](_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf) pBuf = ([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* [AK\_RESTRICT](_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf))io\_pBuffer->[GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)(i);

coeffBegin = m\_coeff; // restart the ramp.

uFramesProcessed = 0;

while (uFramesProcessed < io\_pBuffer->uValidFrames)

{

m\_previousOutput[i] = pBuf[uFramesProcessed] =

pBuf[uFramesProcessed] + (m\_previousOutput[i] - pBuf[uFramesProcessed]) \* coeffBegin;

coeffBegin += coeffStep; // increase by coeffStep every sample.

++uFramesProcessed;

}

}

m\_coeff = coeffBegin; // save the current value for the next frame.

}

现在我们构建了一个能够实现简单的低通滤波效果并实时控制截止频率的基础功能插件。接下来，我们说说设计方面的一些问题。

# 封装处理逻辑

现在，所有的信号处理逻辑都写在了插件主类内。这种设计模式存在很多弊端：

- 插件主类会显得很臃肿，等到添加新的处理功能来构建较为复杂的效果时，情况会更加糟糕。
- 很难在需要时将该滤波器用于其他插件。对这种基础处理组件来说更是如此。
- 不符合单一职责原则。

下面我们来重构代码以将滤波处理封装到其自身的类中。首先，依据以下定义在 `SoundEnginePlugin` 文件夹中创建 `FirstOrderLowpass.h` 文件：

// FirstOrderLowpass.h

#pragma once

#include <[AK/SoundEngine/Common/AkCommonDefs.h](_ak_common_defs_8h.html)>

class FirstOrderLowpass

{

public:

FirstOrderLowpass();

~FirstOrderLowpass();

void Setup([AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_sampleRate);

void SetFrequency([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) in\_newFrequency);

void Execute([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* io\_pBuffer, [AkUInt16](_ak_numeral_types_8h_a7100a9b0a3b01df7639c1dc512678219.html#a7100a9b0a3b01df7639c1dc512678219) in\_uValidFrames);

private:

[AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) m\_sampleRate;

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) m\_frequency;

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) m\_coeff;

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) m\_previousOutput;

bool m\_frequencyChanged;

};

接着，在 `FirstOrderLowpass.cpp` 文件中添加实现代码：

// FirstOrderLowpass.cpp

#include "FirstOrderLowpass.h"

#include <cmath>

#ifndef M\_PI

#define M\_PI 3.14159265359

#endif

FirstOrderLowpass::FirstOrderLowpass()

: m\_sampleRate(0)

, m\_frequency(0.0f)

, m\_coeff(0.0f)

, m\_previousOutput(0.0f)

, m\_frequencyChanged(false)

{

}

FirstOrderLowpass::~FirstOrderLowpass() {}

void FirstOrderLowpass::Setup([AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) in\_sampleRate)

{

m\_sampleRate = in\_sampleRate;

}

void FirstOrderLowpass::SetFrequency([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) in\_newFrequency)

{

if (m\_sampleRate > 0)

{

m\_frequency = in\_newFrequency;

m\_frequencyChanged = true;

}

}

void FirstOrderLowpass::Execute([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* io\_pBuffer, [AkUInt16](_ak_numeral_types_8h_a7100a9b0a3b01df7639c1dc512678219.html#a7100a9b0a3b01df7639c1dc512678219) in\_uValidFrames)

{

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98) coeffBegin = m\_coeff, coeffEnd = 0.0f, coeffStep = 0.0f;

if (m\_frequencyChanged)

{

coeffEnd = static\_cast<[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)>(exp(-2.0 \* M\_PI \* m\_frequency / m\_sampleRate));

coeffStep = (coeffEnd - coeffBegin) / in\_uValidFrames;

m\_frequencyChanged = false;

}

[AkUInt16](_ak_numeral_types_8h_a7100a9b0a3b01df7639c1dc512678219.html#a7100a9b0a3b01df7639c1dc512678219) uFramesProcessed = 0;

while (uFramesProcessed < in\_uValidFrames)

{

m\_previousOutput = io\_pBuffer[uFramesProcessed] =

io\_pBuffer[uFramesProcessed] + (m\_previousOutput - io\_pBuffer[uFramesProcessed]) \* coeffBegin;

coeffBegin += coeffStep;

++uFramesProcessed;

}

m\_coeff = coeffBegin;

}

然后，直接在插件主类中创建一组 `FirstOrderLowpass` 对象（每个声道一个），然后通过调用 `Setup` 函数来使用它们。

// LowpassFX.h

#include "FirstOrderLowpass.h"

#include <vector>

//...

private:

std::vector<FirstOrderLowpass> m\_filter;

// LowpassFX.cpp

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63) [LowpassFX::Init](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8)([AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html)\* in\_pAllocator, [AK::IAkEffectPluginContext](class_a_k_1_1_i_ak_effect_plugin_context.html)\* in\_pContext, [AK::IAkPluginParam](class_a_k_1_1_i_ak_plugin_param.html)\* in\_pParams, [AkAudioFormat](struct_ak_audio_format.html)& in\_rFormat)

{

//...

m\_filter.resize(in\_rFormat.[GetNumChannels](struct_ak_audio_format_a4fbe6f5b2d3e04945c6c1444f14c2118.html#a4fbe6f5b2d3e04945c6c1444f14c2118)());

for (auto & filterChannel : m\_filter) { filterChannel.Setup(in\_rFormat.[uSampleRate](struct_ak_audio_format_ad94d7b21266cb1d8a9aa5557f875d0fa.html#ad94d7b21266cb1d8a9aa5557f875d0fa)); }

//...

}

void LowpassFX::Execute([AkAudioBuffer](class_ak_audio_buffer.html)\* io\_pBuffer)

{

if (m\_pParams->m\_paramChangeHandler.HasChanged(PARAM\_FREQUENCY\_ID))

{

for (auto & filterChannel : m\_filter) { filterChannel.SetFrequency(m\_pParams->RTPC.fFrequency); }

}

const [AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) uNumChannels = io\_pBuffer->[NumChannels](class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f)();

for ([AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce) i = 0; i < uNumChannels; ++i)

{

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* [AK\_RESTRICT](_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf) pBuf = ([AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)\* [AK\_RESTRICT](_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf))io\_pBuffer->[GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)(i);

m\_filter[i].Execute(pBuf, io\_pBuffer->[uValidFrames](class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd));

}

}

[AkAudioBuffer::GetChannel](class_ak_audio_buffer_ad2bc3b8ddd61eaa0c111798d5f9e8c9c.html#ad2bc3b8ddd61eaa0c111798d5f9e8c9c)

AkSampleType \* GetChannel(AkUInt32 in\_uIndex)

**Definition:** [AkCommonDefs.h:421](_ak_common_defs_8h_source.html#l00421)

[AkUInt16](_ak_numeral_types_8h_a7100a9b0a3b01df7639c1dc512678219.html#a7100a9b0a3b01df7639c1dc512678219)

uint16\_t AkUInt16

Unsigned 16-bit integer

**Definition:** [AkNumeralTypes.h:33](_ak_numeral_types_8h_source.html#l00033)

[AK](namespace_a_k.html)

Definition of data structures for AkAudioObject

**Definition:** [AkWwiseSDKVersion.cs:31](_ak_wwise_s_d_k_version_8cs_source.html#l00030)

[AK.Wwise::Plugin::V1::DataWriter](class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer.html)

Interface used to write data during sound bank generation.

**Definition:** [HostDataWriter.h:245](_host_data_writer_8h_source.html#l00244)

[AK::IAkPluginParam](class_a_k_1_1_i_ak_plugin_param.html)

**Definition:** [IAkPlugin.h:709](_i_ak_plugin_8h_source.html#l00708)

[AkAudioBuffer::NumChannels](class_ak_audio_buffer_a4523322478ec9a0f9de0c7c72e65df2f.html#a4523322478ec9a0f9de0c7c72e65df2f)

AkForceInline AkUInt32 NumChannels() const

Get the number of channels.

**Definition:** [AkCommonDefs.h:337](_ak_common_defs_8h_source.html#l00337)

[AK::Comm::Init](namespace_a_k_1_1_comm_a596691b552b507c26b4df958ee1c6de8.html#a596691b552b507c26b4df958ee1c6de8)

AKSOUNDENGINE\_API AKRESULT Init(const AkCommSettings &in\_settings)

[AK.Wwise::Plugin::V1::DataWriter::WriteReal32](class_a_k_1_1_wwise_1_1_plugin_1_1_v1_1_1_data_writer_a8d9b58e2ecba7f95721d4b89b7f9630f.html#a8d9b58e2ecba7f95721d4b89b7f9630f)

bool WriteReal32(float in\_value)

Writes a 32-bit, single-precision floating point value.

**Definition:** [HostDataWriter.h:427](_host_data_writer_8h_source.html#l00427)

[AkReal32](_ak_numeral_types_8h_afc38459f26e2b23defe588026e886a98.html#afc38459f26e2b23defe588026e886a98)

float AkReal32

32-bit floating point

**Definition:** [AkNumeralTypes.h:43](_ak_numeral_types_8h_source.html#l00043)

[AkAudioBuffer::uValidFrames](class_ak_audio_buffer_ab7f90fd99119b56e92e4cbf3559f98cd.html#ab7f90fd99119b56e92e4cbf3559f98cd)

AkUInt16 uValidFrames

Number of valid sample frames in the audio buffer

**Definition:** [AkCommonDefs.h:502](_ak_common_defs_8h_source.html#l00502)

[AkPluginParamID](_ak_typedefs_8h_a4cb8ff0b7014efdaa21697f4ef928926.html#a4cb8ff0b7014efdaa21697f4ef928926)

AkInt16 AkPluginParamID

Source or effect plug-in parameter ID

**Definition:** [AkTypedefs.h:45](_ak_typedefs_8h_source.html#l00045)

[AK::IAkPluginMemAlloc](class_a_k_1_1_i_ak_plugin_mem_alloc.html)

**Definition:** [IAkPluginMemAlloc.h:42](_i_ak_plugin_mem_alloc_8h_source.html#l00041)

[READBANKDATA](_ak_bank_read_helpers_8h_a18513ab855bc8316634d74b9a17138c5.html#a18513ab855bc8316634d74b9a17138c5)

#define READBANKDATA(\_Type, \_Ptr, \_Size)

Read and return bank data of a given type, incrementing running pointer and decrementing block size f...

**Definition:** [AkBankReadHelpers.h:225](_ak_bank_read_helpers_8h_source.html#l00225)

[AKRESULT](_ak_enums_8h_a64f7d1f79613cc4dcc49a4efba6caa63.html#a64f7d1f79613cc4dcc49a4efba6caa63)

AKRESULT

**Definition:** [AkEnums.h:32](_ak_enums_8h_source.html#l00031)

[AkCommonDefs.h](_ak_common_defs_8h.html)

[AkUInt32](_ak_numeral_types_8h_a39c6c5d577901802ca77775760b704ce.html#a39c6c5d577901802ca77775760b704ce)

uint32\_t AkUInt32

Unsigned 32-bit integer

**Definition:** [AkNumeralTypes.h:35](_ak_numeral_types_8h_source.html#l00035)

[AkAudioBuffer](class_ak_audio_buffer.html)

**Definition:** [AkCommonDefs.h:310](_ak_common_defs_8h_source.html#l00309)

[AkAudioFormat::GetNumChannels](struct_ak_audio_format_a4fbe6f5b2d3e04945c6c1444f14c2118.html#a4fbe6f5b2d3e04945c6c1444f14c2118)

AkForceInline AkUInt32 GetNumChannels() const

**Definition:** [AkCommonDefs.h:73](_ak_common_defs_8h_source.html#l00073)

[AK\_RESTRICT](_platforms_2_windows_2_ak_types_8h_ab66f3fb84361798a69b92a110f8a14cf.html#ab66f3fb84361798a69b92a110f8a14cf)

#define AK\_RESTRICT

Refers to the \_\_restrict compilation flag available on some platforms

**Definition:** [AkTypes.h:95](_platforms_2_windows_2_ak_types_8h_source.html#l00095)

[AkAudioFormat](struct_ak_audio_format.html)

Defines the parameters of an audio buffer format.

**Definition:** [AkCommonDefs.h:61](_ak_common_defs_8h_source.html#l00060)

[AK::IAkEffectPluginContext](class_a_k_1_1_i_ak_effect_plugin_context.html)

**Definition:** [IAkPlugin.h:370](_i_ak_plugin_8h_source.html#l00369)

[AkAudioFormat::uSampleRate](struct_ak_audio_format_ad94d7b21266cb1d8a9aa5557f875d0fa.html#ad94d7b21266cb1d8a9aa5557f875d0fa)

AkUInt32 uSampleRate

Number of samples per second

**Definition:** [AkCommonDefs.h:62](_ak_common_defs_8h_source.html#l00062)